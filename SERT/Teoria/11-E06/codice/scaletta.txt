SCALETTA LEZIONE SERT 10.12.2020 (E06)

1 Aggiungere a _init() l'inizializzazione della tabella dei
  vettori di interruzione
  1.1 Riprendere slides lez-E03b per modalita' gestione delle eccezioni
  1.2 Consultazione del manuale "ARM Cortex-A8 TRM" per determinare la
      posizione della tabella dei vettori interruzione (3.2.25, 3.2.68)
  1.3 Scrittura della funzione get_vectors_address() in bbb_vectors.h:
      +-----------------------------------------------------------------+
      |static inline u32 *get_vectors_address(void)                     |
      |{                                                                |
      |  u32 v;                                                         |
      |  __asm__ __volatile__("mrc p15, 0, %0, c1, c0, 0\n":"=r"(v)::); |
      |  if (v & (1 << 13))                                             |
      |      return (u32 *) 0xffff0000;                                 |
      |  __asm__ __volatile__("mrc p15, 0, %0, c12, c0, 0\n":"=r"(v)::);|
      |  return (u32 *) v;                                              |
      |}                                                                |
      +-----------------------------------------------------------------+
  1.4 Scrittura della funzione init_vectors() in init.c
      +-----------------------------------------------------------------+
      |static void init_vectors(void)                                   |
      |{                                                                |
      |    extern void _reset(void);                                    |
      |    volatile u32 *vectors = get_vectors_address();               |
      |#define LDR_PC_PC 0xe59ff018                                     |
      |    vectors[0] = LDR_PC_PC; /* Reset / Reserved */               |
      |    vectors[1] = LDR_PC_PC; /* Undefined instruction */          |
      |    vectors[2] = LDR_PC_PC; /* Software interrupt */             |
      |    vectors[3] = LDR_PC_PC; /* Prefetch abort */                 |
      |    vectors[4] = LDR_PC_PC; /* Data abort */                     |
      |    vectors[5] = LDR_PC_PC; /* Hypervisor trap */                |
      |    vectors[6] = LDR_PC_PC; /* Interrupt request (IRQ) */        |
      |    vectors[7] = LDR_PC_PC; /* Fast interrupt request (FIQ) */   |
      |    vectors[8] = (u32) _reset;  /* Reset / Reserved */           |
      |    vectors[9] = (u32) panic0;  /* Undefined instruction */      |
      |    vectors[10] = (u32) panic0; /* Software interrupt */         |
      |    vectors[11] = (u32) panic0; /* Prefetch abort */             |
      |    vectors[12] = (u32) panic1; /* Data abort */                 |
      |    vectors[13] = (u32) panic0; /* Hypervisor trap */            |
      |    vectors[14] = (u32) panic0;   /* Interrupt request (IRQ) */  |
      |    vectors[15] = (u32) panic0; /* Fast interrupt request (FIQ)*/|
      |#undef LDR_PC_PC                                                 |
      |}                                                                |
      +-----------------------------------------------------------------+
  1.5 Aggiungere invocazione di init_vectors() in _init()
  1.6 Prova del funzionamento: aggiungere asm("swi 0") in main()
  1.7 Sostituire panic0() con panic2() in vector[10]

2 Consultare i manuali per informazioni su come si programma
  la porta seriale
  2.1 Il manuale "AM335x TRM" dedica piu' di 100 pagine alla
      programmazione delle porte seriali. Tre possibilita':
      2.1.1 Programmazione tramite DMA: nel trasferimento dei dati non e'
            coinvolta la CPU
      2.1.2 Programmazione tramite interruzioni: la CPU trasferisce i
            dati, le interruzioni segnalano la presenza di dati in
            ricezione o la disponibilita' di spazio nel buffer di
            trasmissione
      2.1.3 Programmazione tramite CPU polling: la CPU trasferisce i dati
            e controlla attivamente lo stato dei buffer di ricezione/
            trasmissione
  2.2 Scegliere la strada piu' semplice: programmare la porta seriale
      tramite CPU polling. Determinare posizione e funzionamento dei
      registri di I/O della porta seriale, in particolare il registro di
      dati e quello che informa sullo stato del buffer di trasmissione
      2.2.1 Registro THR (Transmit Hold Register)
            Scrittura: dato da trasmettere
      2.2.2 Registro LSR (Line Status Register)
            Bit 5: TXFIFOE (Trasmit Hold Register Empty)
   2.3 Scrivere bbb_uart.h aggiungendo le definizioni occorrenti
       +-------------------------------------------------------+
       |#define UART0_BASE      0x44e09000                     |
       |iomemdef(UART0_THR,         UART0_BASE + 0);           |
       |iomemdef(UART0_LSR,         UART0_BASE + 0x14);        |
       |#define LSR_TXFIFOE         (1u<<5)                    |
       +-------------------------------------------------------+
       2.3.1 Aggiungere include bbb_uart.h in beagleboneblack.h
   2.4 Scrivere file uart0.c
       2.4.1 Funzione putc() per scrivere un singolo carattere
             +-----------------------------------------------+
             |int putc(int ch)                               |
             |{                                              |
             |  while (!(iomem(UART0_LSR) & LSR_TXFIFOE))    |
             |      /* do nothing */ ;                       |
             |  iomem(UART0_THR) = ch;                       |
             |  return 1;                                    |
             |}                                              |
             +-----------------------------------------------+
       2.4.2 Aggiungere extern per putc() in comm.h:
             extern void putc(int);
       2.4.3 Provare la funzione putc() modificando main()
       2.4.4 Funzione puts() per scrivere una stringa di caratteri
             +-----------------------------------------------+
             |int puts(const char *st)                       |
             |{                                              |
             |  int v = 0;                                   |
             |  while (*st) {                                |
             |      v += putc(*st);                          |
             |      if (*st++ == '\n')                       |
             |          v += putc('\r');                     |
             |  }                                            |
             |  return v;                                    |
             |}                                              |
             +-----------------------------------------------+
       2.4.5 Aggiungere extern per puts() in comm.h
   2.5 Rinominare main() in endless_led_blinking()
   2.6 Scrivere nuova main() che stampa su seriale ed invoca
       endless_led_blinking()

3 Scrivere la funzione putnl() per inserire 'new line':
  +-----------------------------------------------+
  |int putnl(void)                                |
  |{                                              |
  |    putc('\n');                                |
  |    putc('\r');                                |
  |    return 2;                                  |
  |}                                              |
  +-----------------------------------------------+

4 Scrivere la funzione puth() in uart0.c per stampare un valore senza
  segno in esadecimale
  +--------------------------------------------------+
  |int puth(unsigned long v)                         |
  |{                                                 |
  |    int i, d, w = 0;                              |
  |    u32 mask;                                     |
  |                                                  |
  |    mask = 0xf0000000;                            |
  |    for (i = 0; mask != 0; i += 4, mask >>= 4) {  |
  |        d = (v & mask) >> (28 - i);               |
  |        w += putc(d + (d > 9 ? 'a' - 10 : '0'));  |
  |    }                                             |
  |    return w;                                     |
  |}                                                 |
  +--------------------------------------------------+

5 Scrivere la funzione putu() in uart0.c per stampare un valore senza
  segno in decimale
  +--------------------------------------------------+
  |int putu(unsigned long v)                         |
  |{                                                 |
  |    char buf[11];                                 |
  |    int i, r, w = 0;                              |
  |    if (v < 10ul) {                               |
  |        w += putc(v + '0');                       |
  |        return w;                                 |
  |    }                                             |
  |    i = 10;                                       |
  |    buf[i] = '\0';                                |
  |    while (v != 0) {                              |
  |        unsigned long t = v / 10;                 |
  |        r = v - t * 10;                           |
  |        v = t;                                    |
  |        buf[--i] = (char)(r + '0');               |
  |    }                                             |
  |    w += puts(buf + i);                           |
  |    return w;                                     |
  |}                                                 |
  +--------------------------------------------------+

6 Scrivere la funzione putd() in uart0.c per stampare un valore con
   segno in decimale
   +-------------------------------------------------+
   |int putd(long v)                                 |
   |{                                                |
   |    int w = 0;                                   |
   |    if (v < 0) {                                 |
   |        w += putc('-');                          |
   |        v = -v;                                  |
   |    }                                            |
   |    w += putu(v);                                |
   |    return w;                                    |
   |}                                                |
   +-------------------------------------------------+

7 Scrivere la funzione putf() in uart0.c per stampare un valore in
   virgola mobile
   +---------------------------------------------------+
   |int putf(double v, int prec)                       |
   |{                                                  |
   |    int i, w = 0;                                  |
   |    if (v < 0.0) {                                 |
   |        w += putc('-');                            |
   |        v = -v;                                    |
   |    }                                              |
   |    w += putu(v);                                  |
   |    w += putc('.');                                |
   |    for (i = 0; i < prec; ++i) {                   |
   |        v = v - (int)v;                            |
   |        v = v * 10;                                |
   |        w += putc('0' + (int)v);                   |
   |    }                                              |
   |    return w;                                      |
   |}                                                  |
   +---------------------------------------------------+

8 Provando la funzione putf() si riscontra una eccezione di tipo
  'Data abort' (possibile anche 'Undefined instruction')
  8.1 Dal manuale "ARM Cortex Programming Guide" 6.1.3 apprendiamo
      che il coprocessore VFP deve essere esplicitamente abilitato
      dopo il reset
      h.1.1 Abilitando l'accesso ai coprocessori CP10 e CP11 tramite
            il Coprocessor Control Access Register
      h.1.2 Impostando un bit nel registro VFP FPEXC
  8.2 Dal manuale "ARM Cortex-A8 TRM" 3.2.27 apprendiamo come si
      modifica il Coprocessor Control Access Register
  8.3 Modifichiamo bbb_cpu.h aggiungendo le macro necessarie:
      +-----------------------------------------------------------------+
      |#define set_en_bit_in_fpexc() do { \                             |
      |    int dummy; \                                                 |
      |    __asm__ __volatile__ ("fmrx %0,fpexc\n\t" \                  |
      |                         "orr  %0,%0,#0x40000000\n\t" \          |
      |                         "fmxr fpexc,%0" : "=r" (dummy) : :); \  |
      |} while (0)                                                      |
      |#define read_coprocessor_access_control_register() ({ \          |
      |    u32 value; \                                                 |
      |    __asm__ __volatile__ ("mrc p15, 0, %[reg], c1, c0, 2" : \    |
      |                          [reg] "=r" (value) : : "memory"); \    |
      |    value; })                                                    |
      |#define write_coprocessor_access_control_register(value) \       |
      |    __asm__ __volatile__ ("mcr p15, 0, %[reg], c1, c0, 2" : : \  |
      |                          [reg] "r" (value) : "memory")          |
      +-----------------------------------------------------------------+
  8.4 Modifichiamo _init() aggiungendo la call alla funzione init_vfp():
      +-----------------------------------------------------------------+
      |static void init_vfp(void)                                       |
      |{                                                                |
      | u32 v = read_coprocessor_access_control_register();             |
      | v |= (1u << 20) | (1u << 22);                                   |
      | write_coprocessor_access_control_register(v);                   |
      | data_sync_barrier();                                            |
      | set_en_bit_in_fpexc();                                          |
      |}                                                                |
      +-----------------------------------------------------------------+

9 Scrivere la funzione putcn() in uart0.c per scrivere una stringa
   costituita da un carattere ripetuto un dato numero di volte
   +---------------------------------------------------+
   |int putcn(int ch, int n)                           |
   |{                                                  |
   |    int i;                                         |
   |    if (n <= 0)                                    |
   |        return 0;                                  |
   |    for (i = 0; i < n; ++i)                        |
   |        putc(ch);                                  |
   |    return n;                                      |
   |}                                                  |
   +---------------------------------------------------+

10 Prova delle nuove funzioni:
   10.1 Aggiungere i prototipi delle nuove funzioni in comm.h
   10.2 Riscrivere la funzione banner() in main.c
        +---------------------------------------------------------------+
        |static void banner(void)                                       |
        |{                                                              |
        |  putcn('=',65); putnl();                                      |
        |  puts("SERT: System Environment for Real-Time, "              |
        |       "version 2019.11\n");                                   |
        |  puts("Marco Cesati, SPRG, DICII, University of Rome "        |
        |       "Tor Vergata\n");                                       |
        |  putcn('=',65); putnl();                                      |
        |}                                                              |
        +---------------------------------------------------------------+

11 Scrivere la funzione printf() in printf.c
   11.1 Modificare la funzione banner() in main.c
        +---------------------------------------------------------------+
        |static void banner(void)                                       |
        |{                                                              |
        |   putcn('=', 65); putnl();                                    |
        |   printf(                                                     |
        |   "SERT: System Environment for Real-Time, version %u.%x\n"   |
        |       "Marco Cesati, SPRG, DICII, University of Rome "        |
        |       "Tor Vergata\n",                                        |
        |       2019, 17);                                              |
        |   putcn('=', 65); putnl();                                    |
        |}                                                              |
        +---------------------------------------------------------------+

==========

/*
vim: tabstop=4 softtabstop=4 expandtab list colorcolumn=74 tw=74
*/
