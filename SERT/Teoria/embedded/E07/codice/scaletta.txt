SCALETTA LEZIONE SERT 11.12.2020 (E07)

1 Gestione delle interruzioni (IRQ)
  1.1 Nel manuale della Beaglebone Black non si trovano informazioni
      specifiche sulla gestione delle interruzioni (IRQ)
  1.2 Il manuale del chip AM335 (TRM) dedica il capitolo 6 alla gestione
      delle interruzioni (60+ pagine). Vengono riassunte qui solo le
      informazioni piu' importanti
  1.3 FIQ ("fast interrupts") non sono utilizzabili su questo processore
  1.4 Un circuito "Interrupt Controller" si occupa di processare i
      segnali di interruzione provenienti dalle periferiche,
      mascherandoli e/o ordinandoli per priorita', poi produce i segnali
      di interruzione verso la CPU
  1.5 Sono gestite 128 linee di IRQ 'level-triggered' tramite diversi
      registri
       1.5.1 Registri MPU_INTC.INTC_MIRn (n=0...3) servono a mascherare
             ciascuna linea individualmente
       1.5.2 Registri MPU_INTC.INTC_ILRm (m=0...127) servono a
             selezionare per ciascuna linea IRQ o FIQ (quest'ultimo non
             disponibile su BBB), ed il valore di priorita'
             1.5.2.1 Priorita' massima associata al valore 0
             1.5.2.2 Priorita' minima associata al valore 63
             1.5.2.3 In caso di parita' di priorita' vince l'interruzione
                     con il numero piu' alto
       1.5.3 Registri MPU_INTC.INTC_ITRn (n=0...3) indicano lo stato di
             ciascuna linea prima del mascheramento
       1.5.4 Registri MPU_INTC.INTC_PENDING_IRQn (n=0...3) indicano lo
             stato di ciascuna linea IRQ (non FIQ) dopo mascheramento e
             ordinamento per priorita' 
       1.5.5 Registro MPU_INTC.INTC_THRESHOLD consente di indicare un
             livello di soglia delle priorita': tutti gli IRQ di
             priorita' inferiore o uguale alla soglia vengono mascherati
             automaticamente
             1.5.5.1 Priorita' massima associata al valore 0
             1.5.5.2 Priorita' minima associata al valore 63
             1.5.5.3 Valore 0xff: disabilita il meccanismo a soglia
      1.5.6 Registro MPU_INTC.INTC_SIR_IRQ indica il numero di
            interruzione pendente di priorita' massima
      1.5.7 Registro MPU_INTC.INTC_CONTROL_NEWIRQAGR serve a confermare 
            l'avvenuta gestione di una interruzione e quindi a far
            selezionare la successiva interruzione pendente di priorita'
            massima
  1.6 Ricavare indirizzi di base dei vari registri INTC (in "AM335x TRM")

2 I punti salienti della gestione delle interruzioni in SERT
  2.1 Utilizzo solo interruzioni IRQ (FIQ non disponibili su BBB)
  2.2 Il modo normale di esecuzione per il sistema e' SYSTEM
       2.2.1 Tutti i "task" sono privilegiati
  2.3 I gestori delle interruzioni non fanno uso di uno stack diverso da
      quello del modo SYSTEM
      2.3.1 Il salvataggio del contesto di esecuzione all'occorrenza di
            una interruzione deve essere effettuato sullo stack SYSTEM
      2.3.2 Il modo corrente della CPU e' indicato da bit nel registro
            CPSR:
            2.3.2.1 modo SYSTEM: maschera 0x1f
            2.3.2.2 modo IRQ:    maschera 0x17
            2.3.2.3 modo FIQ:    maschera 0x11
  2.4 La gestione delle interruzioni ha tre livelli:
      2.4.1 Livello basso: procedura Assembler definita all'offset 0x18
            della tabella delle eccezioni (vedi slide 41 della lez. E03b)
            che salva e recupera il contesto di esecuzione
      2.4.2 Livello intermedio: procedura C che interagisce con l'IC e
            ricava l'indirizzo della ISR da eseguire 
      2.4.3 Livello alto: ISR, ossia funzione C specifica per
            l'interruzione attivata
   2.5 Sezioni critiche implementate tramite disabilitazione delle
       interruzioni
       2.5.1 Il bit 0x80 del registro cpsr disabilita gli IRQ
       2.5.2 Il bit 0x40 del registro cpsr disabilita   i FIQ
       2.5.3 Mediante le istruzioni cpsid e cpsie

3 Scrivere il file bbb_intc.h con le definizioni dei registri
  +---------------------------------------------------------------+
  |#define INTC_BASE               0x48200000                     |
  |iomemdef(INTC_SYSCONFIG,        INTC_BASE + 0x10);             |
  |iomemdef(INTC_SIR_IRQ,          INTC_BASE + 0x40);             |
  |iomemdef(INTC_CONTROL,          INTC_BASE + 0x48);             |
  |iomemdef(INTC_THRESHOLD,        INTC_BASE + 0x68);             |
  |iomemdef(INTC_ITR_BASE,         INTC_BASE + 0x80);             |
  |iomemdef(INTC_MIR_BASE,         INTC_BASE + 0x84);             |
  |iomemdef(INTC_MIR_CLEAR_BASE,   INTC_BASE + 0x88);             |
  |iomemdef(INTC_MIR_SET_BASE,     INTC_BASE + 0x8c);             |
  |iomemdef(INTC_ISR_SET_BASE,     INTC_BASE + 0x90);             |
  |iomemdef(INTC_ISR_CLEAR_BASE,   INTC_BASE + 0x94);             |
  |iomemdef(INTC_PENDING_IRQ_BASE, INTC_BASE + 0x98);             |
  |iomemdef(INTC_ILR_BASE,         INTC_BASE + 0x100);            |
  |#define NUM_IRQ_LINES   128                                    |
  |#define NEWIRQAGR       0x1                                    |
  |                                                               |
  |#define irq_enable() \                                         |
  |    __asm__ __volatile__("cpsie i" ::: "memory");              |
  |                                                               |
  |#define irq_disable() \                                        |
  |    __asm__ __volatile__("cpsid i" ::: "memory");              |
  +---------------------------------------------------------------+
  3.1 Per le funzioni irq_enable() e irq_disable(), viene usata
      l'istruzione cps (solo in architettura ARMv7)
      3.1.1 Su architetture precedenti occorre leggere, modificare e
            riscrivere il registro CPSR utilizzando le istr. msr e mrs
      3.1.2 Per approfondimenti su cps vedere il manuale "ARM
            Architecture Reference Manual ARMv7-A and ARMv7-R" (issue
            C.c, 20 May 2014), B9.3.2

4 Modificare init.c per inizializzare l'interrupt controller:
   4.1 Scrivere la funzione init_intc():
   +-----------------------------------------------------------------+
   |static void init_intc(void)                                      |
   |{                                                                |
   |    iomem(INTC_MIR_SET_BASE + 0) = 0xffffffffUL;                 |
   |    iomem(INTC_MIR_SET_BASE + 8) = 0xffffffffUL;                 |
   |    iomem(INTC_MIR_SET_BASE + 16) = 0xffffffffUL;                |
   |    iomem(INTC_MIR_SET_BASE + 24) = 0xffffffffUL;                |
   |    iomem(INTC_THRESHOLD) = 0xff;                                |
   |    irq_enable();                                                |
   |}                                                                |
   +-----------------------------------------------------------------+
   4.2 Aggiungere la chiamata a init_intc() in _init()
   4.3 Modificare init_vectors() in init.c:
       +-------------------------------------------------------------+
       |extern void _irq_handler(void);                              |
       |vectors[14] = (u32) _irq_handler;                            |
       +-------------------------------------------------------------+

5 Scrivere la funzione Assembly _irq_handler() in irqhandler.S
  +--------------------------------------+
  |    .equ NO_IRQ,    0x80              |
  |    .equ NO_FIQ,    0x40              |
  |    .equ NO_INT,    (NO_IRQ|NO_FIQ)   |
  |    .equ FIQ_MODE,  0x11              |
  |    .equ IRQ_MODE,  0x12              |
  |    .equ SYS_MODE,  0x1f              |
  |    .section .text                    |
  |    .code 32                          |
  |    .globl _irq_handler               |
  |_irq_handler:                         |
  |    mov     r13,r0                    |
  |    sub     r0,lr,#4                  |
  |    mov     lr,r1                     |
  |    mrs     r1,spsr                   |
  |    msr     cpsr_c,#(SYS_MODE|NO_IRQ) |
  |    stmfd   sp!,{r0,r1}               |
  |    stmfd   sp!,{r2-r3,r12,lr}        |
  |    mov     r0,sp                     |
  |    sub     sp,sp,#(2*4)              |
  |    msr     cpsr_c,#(IRQ_MODE|NO_IRQ) |
  |    stmfd   r0!,{r13,r14}             |
  |    msr     cpsr_c,#(SYS_MODE|NO_IRQ) |
  |    ldr     r12,=_bsp_irq             |
  |    mov     lr,pc                     |
  |    bx      r12                       |
  |    msr     cpsr_c,#(SYS_MODE|NO_INT) |
  |    mov     r0,sp                     |
  |    add     sp,sp,#(8*4)              |
  |    msr     cpsr_c,#(IRQ_MODE|NO_INT) |
  |    mov     sp,r0                     |
  |    ldr     r0,[sp,#(7*4)]            |
  |    msr     spsr_cxsf,r0              |
  |    ldmfd   sp,{r0-r3,r12,lr}^        |
  |    nop                               |
  |    ldr     lr,[sp,#(6*4)]            |
  |    movs    pc,lr                     |
  +--------------------------------------+

6 Definire il gestore di interruzione di medio livello
   6.1 Definire il tipo di dati isr_t e la macro NULL in comm.h
       +-------------------------------------------------------+
       |#define NULL ((void *)0)                               |
       |typedef void (*isr_t)(void);                           |
       +-------------------------------------------------------+
   6.2 Definire due vettori locali ad un file irq.c
       +---------------------------------------------------------------+
       |static isr_t ISR[NUM_IRQ_LINES];                               |
       |unsigned long irqcount[NUM_IRQ_LINES] = { 0, };                |
       +---------------------------------------------------------------+
       6.2.1 ISR memorizza gli indirizzi delle procedure di gestione di
             ciascun IRQ
       6.2.2 irqcount memorizza il numero di occorrenze di interruzioni 
             di ciascun tipo (solo per diagnostica del sistema)
   6.3 Scrivere la funzione C _bsp_irq() in irq.c
       +---------------------------------------------------------------+
       |void _bsp_irq(void)                                            |
       |{                                                              |
       |   isr_t isr;                                                  |
       |   u32 irqno;                                                  |
       |   /* Cancel any soft irq */                                   |
       |   iomem(INTC_ISR_CLEAR_BASE + 0) = 0xffffffffUL;              |
       |   iomem(INTC_ISR_CLEAR_BASE + 8) = 0xffffffffUL;              |
       |   iomem(INTC_ISR_CLEAR_BASE + 16) = 0xffffffffUL;             |
       |   iomem(INTC_ISR_CLEAR_BASE + 24) = 0xffffffffUL;             |
       |   for (;;) {                                                  |
       |       if (iomem(INTC_PENDING_IRQ_BASE + 0) == 0 &&            |
       |           iomem(INTC_PENDING_IRQ_BASE + 8) == 0 &&            |
       |           iomem(INTC_PENDING_IRQ_BASE + 16) == 0 &&           |
       |           iomem(INTC_PENDING_IRQ_BASE + 24) == 0)             |
       |          return;                                              |
       |      /* there are pending unmasked IRQs on some IC */         |
       |      /* read the (highest-priority) IRQ line number */        |
       |      irqno = iomem(INTC_SIR_IRQ);                             |
       |      /* Do nothing if a spurious interrupt is detected        |
       |         (see AM335x TRM, 6.2.5) */                            |
       |      if (irqno < NUM_IRQ_LINES) {                             |
       |         isr = ISR[irqno];                                     |
       |         if (!isr)                                             |
       |            panic0();                                          |
       |         /* invoke the ISR (with IRQ disabled) */              |
       |         isr();                                                |
       |         /* just in case the ISR has left enabled the IRQs */  |
       |         irq_disable();                                        |
       |         ++irqcount[irqno];                                    |
       |      }                                                        |
       |      iomem(INTC_CONTROL) = NEWIRQAGR;                         |
       |      data_sync_barrier();                                     |
       |   }                                                           |
       |}                                                              |
       +---------------------------------------------------------------+
  6.4 Scrivere la funzione register_isr():
      +----------------------------------------------------------------+
      |int register_isr(int n, isr_t func)                             |
      |{                                                               |
      |   if (n >= NUM_IRQ_LINES) {                                    |
      |      printf(                                                   |
      |          "ERROR in register_isr(): IRQ number %u is invalid\n",|
      |             n);                                                |
      |      return 1;                                                 |
      |   }                                                            |
      |   if (ISR[n] != NULL) {                                        |
      |    printf(                                                     |
                "ERROR in register_isr(): IRQ %u already registered\n",|
      |             n);                                                |
      |      return 1;                                                 |
      |   }                                                            |
      |   ISR[n] = func;                                               |
      |   return 0;                                                    |
      |}                                                               |
      +----------------------------------------------------------------+
      6.4.1 Aggiungere il suo prototipo in comm.h

7 Implementazione di un tick periodico
  7.1 Leggere la documentazione ("ARM 335x TRM", ch. 20)
      7.1.1 Registro TLDR: contiene il valore ricaricato dopo overflow
      7.1.2 Registro TCLR: controllo del timer
      7.1.3 Registro TTGR: per forzare overflow
      7.1.4 Registri IRQ_ENABLE_SET/IRQ_ENABLE_CLR: abilita/disabilita
            generazione di IRQ su capture/overflow/match
      7.1.5 IRQ_STATUS: notifica ricezione dell'interruzione
  7.2 Creare il file bbb_timer.h:
      +-----------------------------------------------------------+
      |#define Timer0_Freq 32768   /* Hz */                       |
      |#define HZ          1000    /* Tick frequency (Hz) */      |
      |#define TICK_TLDR       (0xffffffffu-(Timer0_Freq/HZ)+1)   |
      |#define Timer0_IRQ  66                                     |
      |#define Timer0_IRQ_Bank (Timer0_IRQ/32)                    |
      |#define Timer0_IRQ_Bit  (Timer0_IRQ%32)                    |
      |#define Timer0_IRQ_Mask (1u<<Timer0_IRQ_Bit)               |
      |                                                           |
      |#define DMTIMER0_BASE           0x44e05000                 |
      |                                                           |
      |iomemdef(DMTIMER0_IRQSTATUS,         DMTIMER0_BASE + 0x28);|
      |iomemdef(DMTIMER0_IRQENABLE_SET,     DMTIMER0_BASE + 0x2c);|
      |iomemdef(DMTIMER0_IRQENABLE_CLR,     DMTIMER0_BASE + 0x30);|
      |iomemdef(DMTIMER0_TCLR,              DMTIMER0_BASE + 0x38);|
      |iomemdef(DMTIMER0_TLDR,              DMTIMER0_BASE + 0x40);|
      |iomemdef(DMTIMER0_TTGR,              DMTIMER0_BASE + 0x44);|
      |                                                           |
      |#define TCAR_IT_FLAG    (1u << 2)                          |
      |#define OVF_IT_FLAG     (1u << 1)                          |
      |#define MAT_IT_FLAG     (1u << 0)                          |
      +-----------------------------------------------------------+
      7.2.1 L'idea e' quella di generare un interrupt sull'evento
            "overflow" del contatore. A seguito dell'overflow il
            contatore viene ricaricato con il valore contenuto nel
            registro TLDR.  Configurando opportunamente questo registro
            e' possibile indurre un overflow con una certa frequenza,
            dunque generare interruzioni periodiche
      7.2.2 Nel nostro caso TLDR viene caricato con il valore:
              (0xffffffffU-(Timer0_Freq/HZ)+1)
            7.2.2.1 Poiche' ogni secondo il contatore viene incrementato
                    di 32768, vuol dire che ogni millisecondo viene
                    incrementato di 32768/1000 (== 32)
      7.2.3 Aggiungere bbb_timer.h in beagleboneblack.h
   7.3 Scrivere la funzione init_ticks() in tick.c
       +----------------------------------------------------------------+
       |void init_ticks(void)                                           |
       |{                                                               |
       |    irq_disable();                                              |
       |    if (register_isr(Timer0_IRQ, isr_tick) != 0) {              |
       |        irq_enable();                                           |
       |        puts("init_ticks: cannot register isr.\n");             |
       |        panic0();                                               |
       |    }                                                           |
       |    iomem(DMTIMER0_TLDR) = TICK_TLDR;                           |
       |    iomem(DMTIMER0_IRQENABLE_CLR) = TCAR_IT_FLAG | MAT_IT_FLAG; |
       |    iomem(DMTIMER0_IRQENABLE_SET) = OVF_IT_FLAG;                |
       |    iomem(INTC_ILR_BASE + Timer0_IRQ) = 0x0;                    |
       |    iomem(INTC_MIR_CLEAR_BASE + 8 * Timer0_IRQ_Bank) =          |
       |           Timer0_IRQ_Mask);                                    |
       |    iomem(DMTIMER0_TCLR) = 0x3; /* Auto-reload, start */        |
       |    loop_delay(10000);                                          |
       |    iomem(DMTIMER0_TTGR) = 1;                                   |
       |    irq_enable();                                               |
       |}                                                               |
       +----------------------------------------------------------------+
      7.3.1 Aggiungere il prototipo di init_ticks() in comm.h
      7.3.2 Invocare init_ticks() in _init()
  7.4 Scrivere la funzione isr_tick() in tick.c:
      +--------------------------------------------------+
      |volatile unsigned long ticks = 0;                 |
      |static void isr_tick(void)                        |
      |{                                                 |
      |    iomem(DMTIMER0_IRQSTATUS) = OVF_IT_FLAG;      |
      |    ++ticks;                                      |
      |}                                                 |
      +--------------------------------------------------+
 7.5 Aggiungere 'extern unsigned long ticks;' a comm.h
 7.6 Aggiungere la stampa del valore di ticks in endless_led_blinking():
     +---------------------------------------------------+
     |static void endless_led_blinking(void)             |
     |{                                                  |
     |   int state = 1;                                  |
     |                                                   |
     |   for(;;) {                                       |
     |      loop_delay(10000000);                        |
     |      leds_off_mask(0xf);                          |
     |      leds_on_mask(state);                         |
     |      state = (state+1) & 0xf;                     |
     |      printf("Ticks: %u\n", ticks);                |
     |   }                                               |
     |}                                                  |
     +---------------------------------------------------+
  7.7 Eseguire per verificare il corretto funzionamento

8 Funzione mdelay() basata sul tick periodico
  8.1 Scrittura funzione in delay.c
      +---------------------------------------------------+
      |inline void mdelay(unsigned long msec)             |
      |{                                                  |
      |    unsigned int tckd = (msec*HZ+999)/1000;        |
      |    unsigned long expire = ticks + tckd;           |
      |    while (ticks < expire)                         |
      |        cpu_wait_for_interrupt();                  |
      |}                                                  |
      +---------------------------------------------------+
      8.1.1 tckd e' la parte intera superiore di (msec*HZ)/1000
  8.2 Definire cpu_wait_for_interrupt() in bbb_cpu.h
      +-------------------------------------------------------------+
      |#define cpu_wait_for_interrupt() __asm__ __volatile__("wfi") |
      +-------------------------------------------------------------+
  8.3 Aggiungere il prototipo di mdelay in comm.h
      +------------------------------------+
      | extern void mdelay(unsigned long); |
      +------------------------------------+
  8.4 Modificare main.c e sostituire loop_delay() con mdelay(),
      impostando un ritardo di 1 secondo
  8.5 Problema: cosa accade quando ticks o ticks+tckd vanno in 
      overflow? Il funzionamento non e' corretto!
      8.5.1 Il contatore di 32 bit andra' in overflow dopo
            2^32/(1000*60*60*24) ~ 50 giorni
      8.5.2 Verificare il bug inizializzando ticks con il valore 
            0xffffffff-10*HZ
      8.5.3 Se il sistema embedded e' progettato per funzionare
            ininterrottamente e' necessario considerare questa
            possibilita'
  8.6 Macro per gestire l'overflow del tick (in comm.h):
      +---------------------------------------------------------+
      |#define time_after(a,b)      ((long)((b)-(a))<0)         |
      |#define time_before(a,b)     time_after(b,a)             |
      |#define time_after_eq(a,b)   ((long)((a)-(b))>=0)        |
      |#define time_before_eq(a,b)  time_after_eq(b,a)          |
      +---------------------------------------------------------+
      8.6.1 Modifica mdelay():
      +---------------------------------------------------------+
      |[...]                                                    |
      |    while (time_before(ticks, expire))                   |
      |        cpu_wait_for_interrupt();                        |
      +---------------------------------------------------------+
      8.6.2 Verificare che il bug e' stato corretto
/*
vim: tabstop=4 softtabstop=4 expandtab list colorcolumn=74 tw=73
*/
